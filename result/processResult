import uuid
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import numpy as np
import pandas as pd
import re


def fig_box(names, rk, rd, po, data_np, data_pp):
    fig = make_subplots(rows=2, cols=len(data_np))

    for i in range(len(data_np)):
        fig.add_trace(go.Box(y=data_np[i], x=[names[i]] * len(data_np[i]), name='brak push-down',
                             showlegend=False if i > 0 else True, boxmean='sd', marker_color='#3D9970'),
                      row=1, col=i + 1)

    for i in range(len(data_pp)):
        fig.add_trace(go.Box(y=data_pp[i], x=[names[i]] * len(data_pp[i]), name='z push-down',
                             showlegend=False if i > 0 else True, boxmean='sd', marker_color='#FF4136'),
                      row=2, col=i + 1)
        fig.update_xaxes(title_text="UDF", row=2, col=i + 1, title_standoff=5)

    fig.update_yaxes(title_text="Czas[s]", row=1, col=1, title_standoff=5)
    fig.update_yaxes(title_text="Czas[s]", row=2, col=1, title_standoff=5)

    fig.update_layout(
        title=f'Eksperyment - rozmiar klastra: {rk},<br>'
              f'{"&#160;" * 14}rozmiar danych: {rd}[GB],<br>'
              f'{"&#160;" * 14}przyznana pamięć cache: {po}[GB]',
        plot_bgcolor='rgba(0,0,0,0)',
        font=dict(
            family="Courier New",
            size=8
        )
    )

    return fig


def fig_bars(names, np_, pp_, rk, rd, po):
    fig = go.Figure(data=[
        go.Bar(name='UDF - bez push-down', x=names, y=np_['mean'], error_y=dict(
            type='data',
            array=np_['std'],
            visible=True)),
        go.Bar(name='UDF - z push-down', x=names, y=pp_['mean'], error_y=dict(
            type='data',
            array=pp_['std'],
            visible=True))
    ])
    fig.update_layout(
        title=f'Eksperyment - rozmiar klastra: {rk},<br>'
              f'{"&#160;" * 14}rozmiar danych: {rd}[GB],<br>'
              f'{"&#160;" * 14}przyznana pamięć cache: {po}[GB]',
        plot_bgcolor='rgba(0,0,0,0)',
        yaxis_title='Czas[s]',
        xaxis_title='UDF',
        barmode='group',
        font=dict(
            family="Courier New",
            size=8,
            color="black",
        )
    )
    return fig


def create_bars(df):
    df_data = []
    dfg = df.groupby(['udf', 'rk', 'po', 'rd'])

    for name, group in dfg:
        mean = np.mean(group['time'])
        std = np.std(group['time'])
        q1 = np.quantile(group['time'], 0.25)
        q3 = np.quantile(group['time'], 0.75)
        median = np.median(group['time'])
        data = group['time'].to_list()
        df_data.append([*name, mean, std, q1, median, q3, data])

    df_mean_std = pd.DataFrame(df_data, columns=['udf', 'rk', 'po', 'rd', 'mean', 'std', 'q1', 'median', 'q3', 'data'])

    dfg2 = df_mean_std.groupby(['rk', 'po', 'rd'])

    for name, group in dfg2:
        is_np = group['udf'].str.endswith('np')
        np_ = group[is_np]
        pp_ = group[~is_np]
        names = group['udf'].apply(lambda x: x[:-3]).unique()
        params = group.iloc[0]
        rk, po, rd = params['rk'], params['po'], params['rd']

        img_id = str(uuid.uuid4())
        img_id_bar = img_id + "_bar"
        img_id_box = img_id + "_box"

        f_bar = fig_bars(names, np_, pp_, rk, rd, int(po / 1000))
        f_bar.write_image(f"images/cass/e/{img_id_bar}.pdf")
        f_box = fig_box(names, rk, rd, int(po / 1000), list(np_['data']), list(pp_['data']))
        f_box.write_image(f"images/cass/e/{img_id_box}.pdf")

        latex_df = group.copy().drop('data', axis=1)
        latex_df['po'] = latex_df.po.apply(lambda x: int(x / 1000))

        latex_image_text = r"""
\begin{{figure}}[h]
            \centering
            \includegraphics[width=0.9\linewidth]{{images/cass/e/{0}.pdf}}
            \caption{{{1}}}
            \label{{img/{0}}}
\end{{figure}}
"""
        latex_table = latex_df.to_latex(index=False,
                                        column_format='c|ccc|ccccc',
                                        float_format="%.2f",
                                        caption=f"\\centering Tabele danych dla rysunków "
                                                f"\\ref{{img/{img_id_bar}}} i \\ref{{img/{img_id_box}}}")

        latex_text = [r"\newpage\clearpage",
                      latex_image_text.format(img_id_bar, "\\centering Wykresy przedstawiające średnie czasy"
                                                          " wykonania UDF wraz z odchyleniem standardowym."),
                      latex_table]

        with open('latex.txt', 'a', encoding='UTF-8') as tex:
            tex.write("\n".join(latex_text))

        with open('appendix.txt', 'a', encoding='UTF-8') as tex:
            tex.write(latex_image_text.format(img_id_box, "\\centering Wykresy przedstawiające mediany czasów wykonania"
                                                          " UDF wraz z pierwszym(Q1) i trzecim(Q3) kwantylem.") + "\n\n")


c2p = {'rd': "RD", 'po': 'PC', 'rk': 'RK'}
c2p2 = {'rd': "rozmiar danych", 'po': 'pamięć cache', 'rk': 'rozmiar klastra'}
c2s = {'rd': "[GB]", 'po': '[GB]', 'rk': ''}


def create_d(df):
    df_data = []
    dfg = df.groupby(['udf', 'rk', 'po', 'rd'])

    for name, group in dfg:
        mean = np.mean(group['time'])
        std = np.std(group['time'])
        q1 = np.quantile(group['time'], 0.25)
        q3 = np.quantile(group['time'], 0.75)
        median = np.median(group['time'])
        type = name[0][:-3]
        is_np = True if name[0].endswith('np') else False
        df_data.append([*name, type, is_np, mean, std, q1, median, q3])

    df_c = pd.DataFrame(df_data,
                        columns=['udf', 'rk', 'po', 'rd', 'type', 'is_np', 'mean', 'std', 'q1', 'median', 'q3'])
    create_dd(df_c, 'rk', 'po', 'rd')
    create_dd(df_c, 'rd', 'rk', 'po')
    create_dd(df_c, 'po', 'rd', 'rk')


def create_dd(df_c, c1, c2, c3):
    df_udf = df_c.groupby('type')
    gr_col_1 = c1
    gr_col_2 = c2
    gr_col_3 = c3
    img_id = -1
    for name, group in df_udf:
        group_rd = group.groupby([gr_col_1])

        for name1, group1 in group_rd:
            traces = dict()
            row = 1
            group_rd_ro = group1.groupby([gr_col_2])
            y_max = -float('inf')
            x_data = group1[gr_col_3]
            colors = ["red", "green", "blue", "#00B5F7", "goldenrod"]
            for name2, group2 in group_rd_ro:
                df_np = group2[group2.is_np]
                df_pp = group2[~group2.is_np]

                name_np = f"Brak push-down -<br> {c2p2[gr_col_2]}={name2}{c2s[gr_col_2]}"
                name_pp = f"Z push-down -<br> {c2p2[gr_col_2]}={name2}{c2s[gr_col_2]}"
                y_max = np.max([y_max, df_np['mean'].max(), df_np['mean'].min()])
                c = colors[0]
                colors = colors[1:] + colors[0:1]
                np_gos = go.Scatter(y=df_np['mean'], x=df_np[gr_col_3],
                                    name=name_np, marker_color=c,
                                    error_y=dict(
                                        type='data',
                                        array=df_np['std'],
                                        visible=True))
                pp_gos = go.Scatter(y=df_pp['mean'], x=df_pp[gr_col_3],
                                    name=name_pp, marker_color=c,
                                    error_y=dict(
                                        type='data',
                                        array=df_pp['std'],
                                        visible=True),
                                    line=dict(dash='dash'))
                traces[row] = [np_gos, pp_gos]
                row += 1

            fig = make_subplots(rows=1, cols=len(traces))

            for tk in traces.keys():
                for f in traces[tk]:
                    fig.add_trace(f, row=1, col=tk)
                    fig.update_xaxes(title_text=f"{c2p2[gr_col_3].capitalize()}{c2s[gr_col_3]}",
                                     row=1, col=tk, showgrid=True, tickvals=x_data, linecolor='black',
                                     gridcolor='black')
                fig.update_yaxes(row=1, col=tk, range=[0, y_max * 1.1], showgrid=True,
                                 linecolor='black', gridcolor='black')

            fig.update_layout(
                title=f'Eksperyment - UDF: {name},<br>'
                      f'{"&#160;" * 14}{c2p2[gr_col_1].capitalize()}: {name1}{c2s[gr_col_1]}',
                plot_bgcolor='rgba(0,0,0,0)',
                yaxis_title='Czas[s]',
                font=dict(
                    family="Courier New",
                    size=8,
                    color="black",
                )
            )

            img_id += 1
            img_name = f"images2/cass/e/{c1}_{c2}_{c3}_{img_id}.pdf"
            fig.write_image(img_name)
            latex_df = group1.copy().drop(['type', 'is_np'], axis=1).sort_values([c1, c2, c3])

            latex_image_text = r"""
                \begin{{figure}}[h]
                            \centering
                            \includegraphics[width=1\linewidth]{{{0}}}
                            \caption{{{1}}}
                            \label{{{0}}}
                \end{{figure}}
                """
            latex_table = latex_df.to_latex(index=False,
                                            column_format='c|ccc|ccccc',
                                            float_format="%.2f",
                                            caption=f"\\centering Tabele danych dla rysunku "
                                                    f"\\ref{{{img_name}}}")
            latex_table = re.sub(r"\\toprule\s*.*\s*\\midrule",
                                 r"""\\toprule
\\textbf{}    & \\multicolumn{3}{c|}{\\textbf{Parametry:}} & \\multicolumn{5}{c}{\\textbf{Czasy{[}s{]}}}\\\\ \\cline{2-9}
\\textbf{UDF} & \\textbf{RK}  & \\textbf{PC[GB]} & \\textbf{RD[GB]} & \\textbf{Średnia} & \\textbf{\\begin{tabular}[c]{@{}c@{}}Odch.\\\\ stand.\\end{tabular}} & \\textbf{Q1} & \\textbf{Mediana} & \\textbf{Q3} \\\\
\\midrule""",
                                 latex_table)
            latex_table = re.sub(r"\\begin{table}",
                                 r"\\begin{table}\n\\footnotesize\\fontfamily{cmtt}\\selectfont",
                                 latex_table)

            latex_text = [r"\newpage\clearpage",
                          latex_image_text.format(img_name, "\\centering Wykresy przedstawiające średnie czasy"
                                                            " wykonania UDF wraz z odchyleniem standardowym."),
                          r"\newpage\clearpage",
                          latex_table]

            with open('latex2.txt', 'a', encoding='UTF-8') as tex:
                tex.write("\n".join(latex_text))


if __name__ == '__main__':
    pd.set_option('display.max_colwidth', None)

    df_csv = pd.read_csv('data.csv')
    df2 = df_csv
    df2['po'] = df2.po.apply(lambda x: int(x / 1000))
    dfg_ = df2.groupby(['udf', 'rk', 'po', 'rd'])


    def drop_min_man(t):
        tmin = t.time[t.time > t.time.min()]
        tmax = tmin[tmin < t.time.max()]
        return tmax


    df3 = dfg_.apply(drop_min_man).reset_index()
    create_d(df3)

    # with open('data.csv', 'w') as csv:
    #     csv.write(",".join(k) + "\n")
    #     for udf_r in l_udf_r:
    #         for try_ in udf_r['tries'].values():
    #             s = udf_r['scenario']
    #             csv.write(",".join([udf_r['udf'], str(s['cluster_size']), str(s['java_xms']),
    #                                 str(s['scale']), str(try_['overall_time'])]) + "\n")
    #         etl_time, etl_std, aq_time, ov_time = sum_time(udf_r['tries'])
    #
    #         d = [udf_r['udf']] + list(udf_r['scenario'].values()) + ['{0:.2f}'.format(etl_time), '{0:.2f}'.format(etl_std), '{0:.2f}'.format(aq_time), '{0:.2f}'.format(ov_time)]
    #         x.append(", ".join([str(_) for _ in d]))
    #
    # print("\n".join(x))
    #
    # df = pd.DataFrame(x, columns=k)
    # print(df.sort_values(by=['udf', 'rep_factor', 'java_xms']))
